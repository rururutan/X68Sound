#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
文字化けした日本語コメントを修正するスクリプト
"""

import re
import sys

# 文字化けパターンと正しいコメントのマッピング
comment_fixes = {
    # global.h
    r'// 24\.0.*': '// 24.0us相当',
    r'// .*のクロック.*64': '// 実機のクロックは64',
    r'// .*\s*x/256': '// 全体音量 x/256',
    r'// 64bit.*': '// 64bit境界合わせ',

    # opm.h
    r'// c86ctl.*': '// c86ctl用定義',
    r'// オペレータ.*0.*31': '// オペレータ0～31',
    r'// エンベロープ用カウンタ1.*': '// エンベロープ用カウンタ1 (0,1,2,3,4,5,6,...)',
    r'// エンベロープ用カウンタ2.*': '// エンベロープ用カウンタ2 (3,2,1,3,2,1,3,2,...)',
    r'//.*int.*con.*アルゴリズム.*0.*7': '// アルゴリズム 0～7',
    r'// 0:.*\s*-1:.*': '// 0:無音 -1:出力',
    r'//.*int.*ams.*右シフト.*': '// 右シフト量 31(0), 2(1), 1(2), 0(3)',
    r'//.*LFO.*t.*オーバーフロー.*': '// LFO tのオーバーフロー値',
    r'//.*LFO.*用.*t': '// LFO周期用 t',
    r'//.*LFO.*ランダム.*pt': '// LFOランダム周期用pt',
    r'//.*Lfrq.*LFO.*設定値.*LFRQ': '// LFO周波数設定値 LFRQ',
    r'// OPMreg\$10.*': '// OPMreg$10の値',
    r'// OPMreg\$11.*': '// OPMreg$11の値',
    r'// タイマーA.*オーバーフロー設定値': '// タイマーAのオーバーフロー設定値',
    r'// タイマーA.*カウンター.*': '// タイマーAのカウンター値',
    r'// タイマーB.*オーバーフロー設定値': '// タイマーBのオーバーフロー設定値',
    r'// タイマーB.*カウンター.*': '// タイマーBのカウンター値',
    r'// タイマー.*レジスタ.*OPMreg.*14.*4.*7.*': '// タイマー制御レジスタ (OPMreg$14の下位4ビット+7ビット)',
    r'// OPM.*ステータスレジスタ.*\$E90003.*2.*': '// OPMステータスレジスタ ($E90003の下位2ビット)',
    r'// OPM.*割り込み.*コールバック関数': '// OPM割り込みコールバック関数',
    r'//.*フィルター.*2.*用バッファ': '// ハイパスフィルター2用バッファ',
    r'//.*フィルター.*3.*用バッファ': '// ハイパスフィルター3用バッファ',
    r'// ADPCM.*クロック切り替え.*0:8MHz.*1:4Mhz': '// ADPCMクロック切り替え(0:8MHz 1:4Mhz)',
    r'// 現在指定されている.*OPM.*レジスタ番号': '// 現在指定されているOPMレジスタ番号',
    r'// バックアップ用.*OPM.*レジスタ番号': '// バックアップ用OPMレジスタ番号',
    r'//.*マルチメディアタイマー割り込み': '// マルチメディアタイマー割り込み',
    r'// OPM.*を利用するかどうかのフラグ': '// OPMを利用するかどうかのフラグ',
    r'// ADPCM.*を利用するかどうかのフラグ': '// ADPCMを利用するかどうかのフラグ',
    r'// 0:.*非動作.*1:X68Sound_Start.*2:X68Sound_PcmStart.*': '// 0:非動作 1:X68Sound_Start中 2:X68Sound_PcmStart中',
    r'//.*int.*TotalVolume.*全体音量.*x/256': '// 全体音量 x/256',
    r'// c86ctl.*用': '// c86ctl用',
    r'// OPM.*コマンドバッファをクリア': '// OPMコマンドバッファをクリア',
    r'//.*ハイパスフィルター用バッファをクリア': '// ハイパスフィルター用バッファをクリア',
    r'// 全オペレータをクリア': '// 全オペレータをクリア',
    r'// エンベロープ用カウンタをクリア': '// エンベロープ用カウンタをクリア',
    r'// LFO.*をクリア': '// LFOをクリア',
    r'// PcmBuf.*ポインター.*リセット': '// PcmBufポインターをリセット',
    r'// タイマー関係の初期化': '// タイマー関係の初期化',
    r'// C86CTL.*のロード': '// C86CTLのロード',
    r'// C86CTL.*の初期化.*&.*OPM.*モジュールの探索': '// C86CTLの初期化 & OPMモジュールの探索',
    r'// sin.*テーブルを作成': '// sinテーブルを作成',
    r'// エンベロープ値.*α.*変換テーブルを作成': '// エンベロープ値 → α 変換テーブルを作成',
    r'// エンベロープ値.*Noise.*α.*変換テーブルを作成': '// エンベロープ値 → Noise用α 変換テーブルを作成',
    r'// Noise.*出力をOp.*の.*1/4': '// Noise出力をOpの1/4',
    r'// D1L.*D1l.*変換テーブルを作成': '// D1L → D1l 変換テーブルを作成',
    r'// C1.*M2.*間のφ変換テーブルを作成': '// C1 <-> M2 間のφ変換テーブルを作成',
    r'// Pitch.*周波数変換テーブルを作成': '// Pitch→周波数変換テーブルを作成',
    r'// タイマー.*制御レジスタ': '// タイマー制御レジスタ',
    r'// OpmHpfInp.*OPM.*の出力PCM.*ステレオ.*加算': '// OpmHpfInp[] に OPM の出力PCMをステレオ加算',
    r'// 8\*-2\^17.*8\*\+2\^17': '// 8*-2^17 ～ 8*+2^17',
    r'// 8\*-2\^12.*8\*\+2\^12': '// 8*-2^12 ～ 8*+2^12',
    r'// OPM.*とADPCM.*の音量バランス.*調整': '// OPMとADPCMの音量バランスを調整',
    r'// OutInpAdpcm.*Adpcm.*の出力PCM.*加算': '// OutInpAdpcm[] に Adpcm の出力PCMを加算',
    r'// ノイズ除去': '// ノイズ除去',

    # adpcm.h
    r'// HPF.*用.*16bit PCM Data': '// HPF用 16bit PCM Data',
    r'// HPF.*用': '// HPF用',
    r'// ADPCM.*1.*サンプルのデータの保存': '// ADPCM 1サンプルのデータの保存',
    r'// 割り込みアドレス': '// 割り込みアドレス',
    r'// 0:.*非動作.*1:.*再生中': '// 0:非動作  1:再生中',
    r'// PPI.*レジスタの内容': '// PPI レジスタの内容',
    r'// DMA CSR.*レジスタの内容': '// DMA CSR レジスタの内容',
    r'// DMA CCR.*レジスタの内容': '// DMA CCR レジスタの内容',
    r'// 0:DMA.*非動作.*1:DMA.*再生中': '// 0:DMA非動作  1:DMA再生中',
    r'// ADPCM.*キーオン時の処理': '// ADPCM キーオン時の処理',
    r'// カウントエラー.*転送先アドレス/転送先カウンタ.*': '// カウントエラー(転送先アドレス/転送先カウンタ)',
    r'// バスエラー.*ベースアドレス/ベースカウンタ.*': '// バスエラー(ベースアドレス/ベースカウンタ)',
    r'// Continue.*設定': '// Continue設定',
    r'// チェイニング設定': '// チェイニング設定',
    r'// アレイチェイン': '// アレイチェイン',
    r'// リンクアレイチェイン': '// リンクアレイチェイン',
    r'// ノーマル転送終了': '// ノーマル転送終了',
    r'// DMA.*転送.*1.*バイト.*': '// DMA転送(1バイト)',
    r'// adpcm.*から入力された.*InpPcm.*の値を変化させる': '// adpcmから入力された InpPcm の値を変化させる',
    r'// ADPCM.*停止中': '// ADPCM 停止中',
    r'// 次のADPCM.*データが必要になった場合': '// 次のADPCMデータが必要になった場合',
    r'// InpPcm.*に値を代入': '// InpPcm に値を代入',

    # pcm8.h
    r'// 16bit.*8bitPCM.*の.*1.*前のデータ': '// 16bit,8bitPCMの1つ前のデータ',
    r'// 0.*4:ADPCM.*5:16bitPCM.*6:8bitPCM.*7:.*無効': '// 0～4:ADPCM  5:16bitPCM  6:8bitPCM  7:無効',
    r'// チェイニング設定なし': '// チェイニング設定なし',
    r'// アレイチェイン': '// アレイチェイン',
    r'// リンクアレイチェイン': '// リンクアレイチェイン',
    r'// ADPCM.*キーオン時の処理': '// ADPCM キーオン時の処理',
    r'// カウントエラー.*転送先アドレス/転送先カウンタ.*': '// カウントエラー(転送先アドレス/転送先カウンタ)',
    r'// バスエラー.*ベースアドレス/ベースカウンタ.*': '// バスエラー(ベースアドレス/ベースカウンタ)',
    r'// pcm16.*から入力された.*InpPcm.*の値を変化させる': '// pcm16から入力された InpPcm の値を変化させる',
    r'// ADPCM.*停止中': '// ADPCM 停止中',
    r'// ADPCM.*停止': '// ADPCM 停止',
    r'// ADPCM.*再生開始': '// ADPCM 再生開始',
    r'// OutPcm.*に値を代入': '// OutPcm に値を代入',

    # 一般的な文字化けパターン
    r'//.*\�.*': '',  # 文字化け文字を含むコメントは削除
}

def fix_file(filepath):
    """ファイル内の文字化けコメントを修正"""
    try:
        with open(filepath, 'r', encoding='utf-8', errors='replace') as f:
            content = f.read()

        original = content
        lines = content.split('\n')
        fixed_lines = []

        for line in lines:
            # 文字化け文字(�)を含む行を検出
            if '�' in line and '//' in line:
                # コメント部分のみを削除または置換
                if '//' in line:
                    code_part = line[:line.index('//')]
                    fixed_lines.append(code_part.rstrip())
                else:
                    fixed_lines.append(line)
            else:
                fixed_lines.append(line)

        content = '\n'.join(fixed_lines)

        if content != original:
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(content)
            return True
        return False
    except Exception as e:
        print(f"Error fixing {filepath}: {e}", file=sys.stderr)
        return False

if __name__ == '__main__':
    import glob
    files = glob.glob('/home/user/X68Sound2025/X68Sound/*.h')
    files += glob.glob('/home/user/X68Sound2025/X68Sound/*.cpp')

    fixed_count = 0
    for filepath in files:
        if fix_file(filepath):
            print(f"Fixed: {filepath}")
            fixed_count += 1

    print(f"\nTotal files fixed: {fixed_count}")
